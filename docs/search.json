[
  {
    "objectID": "scripts/carpool.html",
    "href": "scripts/carpool.html",
    "title": "BSF Retreat 2025",
    "section": "",
    "text": "library(readr)\nlibrary(janitor)\nlibrary(dplyr)\nlibrary(httr)\nlibrary(glue)\nlibrary(stringr)\nlibrary(jsonlite)\nlibrary(tidyr)\n\ngeo_coder &lt;- function(postcode) {\n    query &lt;- glue(\"https://nominatim.openstreetmap.org/search?addressdetails=1&q=Australia,+Victoria+{postcode}&format=json\")\n    # print(query)\n    response &lt;- content(\n        GET(url = query, add_headers(`User-Agent` = \"Mozilla/5.0\")),\n        as = \"parsed\", type = \"application/json\")\n    output &lt;- c()\n    output$lat &lt;- as.numeric(response[[1]]$lat)\n    output$lon &lt;- as.numeric(response[[1]]$lon)\n    output$suburb &lt;- response[[1]]$address$suburb\n    Sys.sleep(1)\n    return(output)\n}\n\ndata &lt;- read_csv(\"../data-private/carpool.csv\", col_types = cols(Postcode = col_character())) %&gt;%\n    clean_names() %&gt;%\n    mutate(group = case_when(\n        !is.na(transport_note) ~ \"Special\",\n        carpool == \"I have my own transport and am happy to drive others (carpool)\" ~ \"Driver\",\n        carpool == \"I need help with transport - would like to carpool with someone\" ~ \"Passenger\",\n        TRUE ~ \"Other\"\n    )) %&gt;%\n    mutate(transport_note = replace_na(transport_note, \"\"))\n\ndata_carpool &lt;- data %&gt;% filter(group %in% c(\"Driver\", \"Passenger\", \"Special\"))\n\n# Need to run thru geocoder one row at a time to not overload API\nfor (i in 1:nrow(data_carpool)) {\n    row &lt;- data_carpool[i, ]\n    postcode &lt;- row$postcode\n\n    geocode &lt;- geo_coder(postcode)\n\n    data_carpool$lat[i] &lt;- geocode$lat\n    data_carpool$lon[i] &lt;- geocode$lon\n    data_carpool$suburb[i] &lt;- geocode$suburb\n}\n\nWarning message:\n‚ÄúUnknown or uninitialised column: `lat`.‚Äù\nWarning message:\n‚ÄúUnknown or uninitialised column: `lon`.‚Äù\nWarning message:\n‚ÄúUnknown or uninitialised column: `suburb`.‚Äù\n\n\n\ndata_carpool\n\n\nA tibble: 12 √ó 9\n\n\nname\ninitial\ncarpool\npostcode\ntransport_note\ngroup\nlat\nlon\nsuburb\n\n\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;chr&gt;\n&lt;dbl&gt;\n&lt;dbl&gt;\n&lt;chr&gt;\n\n\n\n\nRachel T\nRT\nI have my own transport and am happy to drive others (carpool)\n3810\nLeaving from 3810 but returning to 3169\nSpecial\n-38.06600\n145.4722\nPakenham\n\n\nBeth L\nBL\nI have my own transport and am happy to drive others (carpool)\n3109\n\nDriver\n-37.78437\n145.1627\nDoncaster East\n\n\nBeulah J\nBJ\nI need help with transport - would like to carpool with someone\n3152\n\nPassenger\n-37.86907\n145.2312\nWantirna South\n\n\nJeremy N\nJN\nI have my own transport and am happy to drive others (carpool)\n3134\n\nDriver\n-37.81199\n145.2256\nRingwood\n\n\nKathryn C\nKC\nI have my own transport and am happy to drive others (carpool)\n3104\n\nDriver\n-37.79345\n145.0821\nBalwyn North\n\n\nRachel N\nRN\nI have my own transport and am happy to drive others (carpool)\n3133\n\nDriver\n-37.85855\n145.1838\nVermont South\n\n\nRosa H\nRH\nI have my own transport and am happy to drive others (carpool)\n3194\nFriday Only (potentially leave out)\nSpecial\n-37.98183\n145.0610\nMentone\n\n\nLynette D\nLD\nI have my own transport and am happy to drive others (carpool)\n3150\n\nDriver\n-37.89002\n145.1720\nGlen Waverley\n\n\nAlice K\nAL\nI need help with transport - would like to carpool with someone\n3104\n\nPassenger\n-37.79345\n145.0821\nBalwyn North\n\n\nBrian C\nBC\nI have my own transport and am happy to drive others (carpool)\n3130\n\nDriver\n-37.81507\n145.1513\nBlackburn\n\n\nHelena C\nHC\nI need help with transport - would like to carpool with someone\n3152\n\nPassenger\n-37.86907\n145.2312\nWantirna South\n\n\nNathan M\nNM\nI need help with transport - would like to carpool with someone\n3084\n\nPassenger\n-37.74925\n145.0710\nHeidelberg\n\n\n\n\n\n\nlibrary(leaflet)\n\n# Create a color palette based on 'category'\npal &lt;- colorFactor(palette = c(\"red\", \"blue\", \"green\"), domain = data_carpool$group)\n\n# Build the map\nmap &lt;- leaflet(data_carpool, width = \"100%\", height = 600) %&gt;%\n  addTiles() %&gt;%\n  addCircleMarkers(\n    lng = ~lon,\n    lat = ~lat,\n    color = ~pal(group),\n    # radius = 8,\n    # stroke = FALSE,\n    fillOpacity = 0.8,\n    popup = ~paste(name, \" \", transport_note)\n  ) %&gt;%\n  addLegend(\"bottomright\", pal = pal, values = ~group, title = \"Group\")\n# save it\nsaveWidget(map, \"carpool_map.html\", selfcontained = FALSE)\n\n# open in your default browser\nbrowseURL(\"carpool_map.html\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BSF Retreat 2025",
    "section": "",
    "text": "Welcome to the BSF Leaders‚Äô Retreat 2025 ü§©\n\n\n\n\n‚Ä¶we have finally booked our location for retreat‚Ä¶\n\n\n\n\n‚Ä¶can you guess where we will be?\n\n\n\n\n\n\n\n\n\nI‚Äôll give you three clues‚Ä¶\n\n\n\n\nClue #1\n\n\n\n\nClue #2\n\n\n\n\n\n\n\n\n\nClue #3: Acts 8:26\n\n\n\n\n‚Ä¶that‚Äôs right, drumroll please‚Ä¶\n\n\n\n\n\n\n\n\n\n‚Ä¶we‚Äôre going to Cowes, Philip Island üéâ\n\n\n\n\n\n\n\n\n\n\n\n\n‚Ä¶keep your eyes peeled for details üëÄüçå\n\n\n\n\n‚Ä¶but in the meanwhile please transfer $70.31 for accommodation (see chat)."
  },
  {
    "objectID": "info.html",
    "href": "info.html",
    "title": "Important Info",
    "section": "",
    "text": "This will be the home page for (most) of your retreat information!"
  },
  {
    "objectID": "info.html#schedule",
    "href": "info.html#schedule",
    "title": "Important Info",
    "section": "Schedule",
    "text": "Schedule\n‚ö†Ô∏è This part is to be confirmed ‚ö†Ô∏è\n\n\n\nTime\nActivity\n\n\n\n\nFRIDAY\n\n\n\n09:00\nWake"
  },
  {
    "objectID": "info.html#menu",
    "href": "info.html#menu",
    "title": "Important Info",
    "section": "Menu",
    "text": "Menu\n‚ö†Ô∏è This part is to be confirmed ‚ö†Ô∏è"
  },
  {
    "objectID": "info.html#pack-list",
    "href": "info.html#pack-list",
    "title": "Important Info",
    "section": "Pack List",
    "text": "Pack List\nIMPORTANT: This accommodation does not include: top & bottom sheets, pillowcases and bath towels. The accommodation does include doona/quilts with covers, pillows without covers, tea towels, hand towels and bathmats.\nEssentials:\n\nBible\nTowels\nPillowcase (or just your own pillow)\nLinen for the bed OR sleeping bag\n\nAlmost Essential:\n\nYour favourite plushie\n\nOptional:\n\nMusical instruments\nGames\nSnacks"
  },
  {
    "objectID": "info.html#beta-fuel-cost-calculator",
    "href": "info.html#beta-fuel-cost-calculator",
    "title": "Important Info",
    "section": "(Beta) Fuel Cost Calculator üß™",
    "text": "(Beta) Fuel Cost Calculator üß™\nThis is a basic calculator to work out how much to split for fuel assuming conservative values of:\n\n10.0L/ 100 km (see here).\nFuel cost of $2.5/ L.\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 400\nfrom shiny import App, render, ui, reactive\nfrom shinywidgets import render_widget, output_widget\n\napp_ui = ui.page_fluid(\n    ui.input_slider(\"n_pax\", \"Number of People in the Car:\", \n        min=2, max=6, value=2),\n    ui.input_numeric(\"length\", \"How long is your drive in km (return)?\", 0),\n    ui.output_text_verbatim(\"show_output\")\n)\n\n\ndef server(input, output, session): \n    @output \n    @render.text\n    def show_output():\n        n_pax = input.n_pax()\n        length = input.length()\n        output = round((length * 0.1*2.5)/n_pax, 2)\n        return f'The cost per person in the car is ${output}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "experimental.html",
    "href": "experimental.html",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "This is an experimental tool to calculate the fuel costs per-passenger. The results are approximations made using certain assumptions (see Methodology section). If the ‚ÄúBy Address‚Äù tool doesn‚Äôt work, you can try using the ‚ÄúBy Distance‚Äù tool after searching up your route on Google Maps.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\ndist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Monash City Church of Christ\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),),\n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = pprint_dist(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = pprint_dist(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = \"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n\n\n    # @render.text()\n    # def geocoder():\n    #   response = calc_geocode()\n    #   name = response['display_name']\n    #   address = response['address']\n    #   if address.get('suburb') is not None:\n    #     suburb = address['suburb']\n    #     suburb_str = f\"and the suburb you have entered is {suburb}\"\n    #   else:\n    #     suburb_str = f\"and suburb is unavailable.\"\n    #   return f'The address you have inputted is: {name} {suburb_str}'\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "experimental.html#beta-fuel-cost-calculator",
    "href": "experimental.html#beta-fuel-cost-calculator",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "This is an experimental tool to calculate the fuel costs per-passenger. The results are approximations made using certain assumptions (see Methodology section). If the ‚ÄúBy Address‚Äù tool doesn‚Äôt work, you can try using the ‚ÄúBy Distance‚Äù tool after searching up your route on Google Maps.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\ndist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Monash City Church of Christ\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),),\n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = pprint_dist(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = pprint_dist(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = \"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n\n\n    # @render.text()\n    # def geocoder():\n    #   response = calc_geocode()\n    #   name = response['display_name']\n    #   address = response['address']\n    #   if address.get('suburb') is not None:\n    #     suburb = address['suburb']\n    #     suburb_str = f\"and the suburb you have entered is {suburb}\"\n    #   else:\n    #     suburb_str = f\"and suburb is unavailable.\"\n    #   return f'The address you have inputted is: {name} {suburb_str}'\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "experimental.html#pack-list",
    "href": "experimental.html#pack-list",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "Pack List",
    "text": "Pack List\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`"
  },
  {
    "objectID": "experimental.html#schedule",
    "href": "experimental.html#schedule",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "Schedule",
    "text": "Schedule\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n\n\nTime\nActivity\n\n\n\n\n09:00\nWake"
  },
  {
    "objectID": "experimental.html#the-menu",
    "href": "experimental.html#the-menu",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "The Menu",
    "text": "The Menu\nQuarto„ÅßÊó•Êú¨Ë™û„ÇÇË°®„Åõ„Çã \\[\n\\int_0^\\infty x dx \\to \\infty\n\\]"
  },
  {
    "objectID": " bonus.html",
    "href": " bonus.html",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "This is an experimental tool to calculate the fuel costs per-passenger. The results are approximations made using certain assumptions (see Methodology section). If the ‚ÄúBy Address‚Äù tool doesn‚Äôt work, you can try using the ‚ÄúBy Distance‚Äù tool after searching up your route on Google Maps.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\ndist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Monash City Church of Christ\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),),\n      \n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = pprint_dist(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = pprint_dist(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = \"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n\n\n    # @render.text()\n    # def geocoder():\n    #   response = calc_geocode()\n    #   name = response['display_name']\n    #   address = response['address']\n    #   if address.get('suburb') is not None:\n    #     suburb = address['suburb']\n    #     suburb_str = f\"and the suburb you have entered is {suburb}\"\n    #   else:\n    #     suburb_str = f\"and suburb is unavailable.\"\n    #   return f'The address you have inputted is: {name} {suburb_str}'\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": " bonus.html#beta-fuel-cost-calculator",
    "href": " bonus.html#beta-fuel-cost-calculator",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "This is an experimental tool to calculate the fuel costs per-passenger. The results are approximations made using certain assumptions (see Methodology section). If the ‚ÄúBy Address‚Äù tool doesn‚Äôt work, you can try using the ‚ÄúBy Distance‚Äù tool after searching up your route on Google Maps.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\ndist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Monash City Church of Christ\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),),\n      \n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = pprint_dist(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = pprint_dist(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = \"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n\n\n    # @render.text()\n    # def geocoder():\n    #   response = calc_geocode()\n    #   name = response['display_name']\n    #   address = response['address']\n    #   if address.get('suburb') is not None:\n    #     suburb = address['suburb']\n    #     suburb_str = f\"and the suburb you have entered is {suburb}\"\n    #   else:\n    #     suburb_str = f\"and suburb is unavailable.\"\n    #   return f'The address you have inputted is: {name} {suburb_str}'\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": " bonus.html#pack-list",
    "href": " bonus.html#pack-list",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "Pack List",
    "text": "Pack List\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`"
  },
  {
    "objectID": " bonus.html#schedule",
    "href": " bonus.html#schedule",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "Schedule",
    "text": "Schedule\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n\n\nTime\nActivity\n\n\n\n\n09:00\nWake"
  },
  {
    "objectID": " bonus.html#the-menu",
    "href": " bonus.html#the-menu",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "The Menu",
    "text": "The Menu\nQuarto„ÅßÊó•Êú¨Ë™û„ÇÇË°®„Åõ„Çã \\[\n\\int_0^\\infty x dx \\to \\infty\n\\]"
  },
  {
    "objectID": "bonus.html",
    "href": "bonus.html",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "Important Disclaimer\n\n\n\n\nCalculations are only estimates since it makes many many approximations.\nIf it can‚Äôt find a road distance the estimates could be wildly incorrect.\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor a more accurate estimate, search your route on Google Maps and enter the distance in the ‚ÄúBy Distance‚Äù tab.\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 1000\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\ndist_heuristics = pd.read_csv(open_url('https://raw.githubusercontent.com/bbpi2/bsf-leaders-retreat-2025/refs/heads/main/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\ndef dist_to_str(dist):\n  return str(round(dist, 2)) + \" km\"\n\ndef cost_to_str(cost):\n  return \"$\" + str(round(cost,2))\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Monash City Church of Christ\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),\n    ),  \n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n      ui.input_numeric(\"length\", \"How long is your drive in km (one way)?\", 0),\n      ui.input_slider(\"n_pax_d\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True),\n      ui.input_task_button(\"search_d\", \"Search\"),\n      ui.output_table(\"table_output_d\")\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      # pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = dist_to_str(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = dist_to_str(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = cost_to_str(cost_ppax) #\"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance (one way)\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance (one way)\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    @output\n    @render.table\n    @reactive.event(input.search_d)\n    def table_output_d():\n      n_pax = input.n_pax()\n      length = input.length()\n      cost_ppax = length * 0.1*2.5/n_pax\n\n      output = []\n      output.append({\"Item\": \"Distance (one way)\", \"Value\": dist_to_str(length)})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_to_str(cost_ppax)})\n      return pd.DataFrame(output)\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)\n\n\n\n\nSource location = where you are coming from.\nDestination location = where you are going (in this case it‚Äôs set to Cowes Phillip Island)\n\n\n\n\nThe Direct Distance is equivalent to the Great Circle Distance and measures out the length (in km) ‚Äúas the crow flies‚Äù which is the shortest distance between two points on a sphere. This is done by taking the latitude & longitude of two the locations and computing the Haversine formula.\nThe Road Distance takes into account the roads required to arrive at the destination. This requires sophisticated graph solving algorithms which is often not worth building yourself. By far this is the more accurate measure.\n\nWe will use an approximation of Road Distance by default - if this cannot be found, then it fallsback to using Direct Distance.\n\n\n\nCalculating the Road Distance requires sophisticate graph solving algorithms and can be grouped in the class of shortest path problem (eg. Dijkstra‚Äôs algorithm). It is not a great idea to write a custom solver because:\n\nThe tool runs almost entirely on the client-side web browser. It is a terrible idea to try to implement graph solving algorithms on web browsers.\nThe effort of writing one up from scratch is useful only insofar as it provides pedogogical value. It just doesn‚Äôt make sense since these tools are already readily available as APIs.\n\nSo if there are APIs available, why can‚Äôt we use it for this tool? Let‚Äôs consider the two main options:\n\nGoogle Maps - this arguable the ‚Äòbest‚Äô way to get routing information, but the API is not free.\nOpen Route Service - this is technically free, but has API limits, which require the user to provide an API key.\n\nSince this tool is built using shinylive, all of its ‚Äòservers‚Äô are client-facing. The client browser is where the backend is run afterall. However, the downside to this is there is no real way to hide API secret keys, since to use the key we will have to eventually expose the secret to the end-user.\n\n\n\nWe are unable to dynamically calculate the route according to user-input of source location because of API restrictions. However, since the destination location is already fixed, we can calculate a set of distances from a list of suburbs. This will be useful in providing the approximation.\n\n\n\nObtain a list of Victorian suburbs and postcodes - Matthew Proctor has a great database of this!\nClean up suburbs dataset - we only really need to keep the metropolitan area subset for our usecase, so we filter by SA4. This ends up being about 800 entries.\nGeocode each suburb to a latitutde & longitude using Nominatim.\nFor each suburb, use Open Route Service to calculate the road distance (only about 20 of them failed).\n\nNow we have a list of suburbs with reference road distances - how do we use this information?\n\n\n\nThis is by far the simplest, but least accurate way. From the user-input, we find the suburb of the source location:\n\nIf a suburb is found, then we impute the road distance from the reference set.\nIf a suburb is not found, we give up on calculating the road distance.\n\n\n\n\nThe obvious flaw with the above method is your location may be in a suburb, but you might actually be closer to another suburb‚Äôs centroid! We can adjust the methodology:\n\nCalculate the direct distance between the source location & each suburb.\nChoose the suburb that is the closest to the source location and use that to impute the road distance value.\n\nThe tricky thing with this method is the computation is \\(\\mathcal{O}(n)\\) according to the complexity of the reference set. This may be fine since we have a short list, but client-side only processing may be a limiting factor.\n\n\n\nThe above method can be flawed as well, since the reference suburb you choose may actually be further away from your destination that the source location. The adjusted methodology is:\n\nCalculate the direct distance between the source location & each suburb: \\(d_{gc}\\)\nFind the suburb that minimises the sum of \\(d_{gc}\\) and the road distance in the reference dataset \\(d_{road}\\)\nThe approximate road distance is precisely this sum.\n\nThe benefit of this method is that it will favour an imputed road distance of a suburb that may be further from the source, but actually on the way to the destination. This method is computationally equivalent to Method 2.\n\n\n\n\n\nUsing approximate road distance where possible.\nThe average fuel efficiency is assumed to be 10L per 100km.\nThe cost of fuel is assumed to be $2.5/L."
  },
  {
    "objectID": "bonus.html#beta-fuel-cost-calculator",
    "href": "bonus.html#beta-fuel-cost-calculator",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "This is an experimental tool to calculate the fuel costs per-passenger.\n\nThe results are approximations made using certain assumptions (see Methodology section).\nIf the ‚ÄúBy Address‚Äù tool doesn‚Äôt work, you can try using the ‚ÄúBy Distance‚Äù tool after searching up your route on Google Maps.\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\nfrom shiny import App, ui, render, reactive\nfrom shinywidgets import render_widget, output_widget\nfrom ipyleaflet import Map, Marker\nfrom math import radians, sin, cos, sqrt, atan2\nfrom pyodide.http import open_url\nimport pandas as pd\nimport requests\n\nDEST_LAT = -38.45956579986424\nDEST_LON = 145.2472955709111\n\ndist_heuristics = pd.read_csv(open_url('/data/metro_vic_suburbs.csv'))\n\n# Haversine formula copied straight from GenAI\ndef great_circle_distance(lat1, lon1, lat2, lon2):\n    # Radius of Earth in kilometers. Use 3956 for miles\n    R = 6371.0\n\n    # Convert degrees to radians\n    œÜ1, Œª1 = radians(lat1), radians(lon1)\n    œÜ2, Œª2 = radians(lat2), radians(lon2)\n\n    # Differences\n    dœÜ = œÜ2 - œÜ1\n    dŒª = Œª2 - Œª1\n\n    # Haversine formula\n    a = sin(dœÜ / 2)**2 + cos(œÜ1) * cos(œÜ2) * sin(dŒª / 2)**2\n    c = 2 * atan2(sqrt(a), sqrt(1 - a))\n\n    return R * c  # Distance in kilometers\n\ndef dist_to_str(dist):\n  return str(round(dist, 2)) + \" km\"\n\ndef cost_to_str(cost):\n  return \"$\" + str(round(cost,2))\n\napp_ui = ui.page_fluid(\n  ui.navset_card_tab(\n    ui.nav_panel(\"By Address\", \n      ui.br(),\n      ui.input_text(\"source_address\", \"Where are you coming from?\", value = \"Monash City Church of Christ\", width = '200%'),\n      ui.input_slider(\"n_pax\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True), \n      ui.input_task_button(\"search\", \"Search\"),\n      # ui.output_text(\"debugger\"),\n      ui.output_text(\"confirmation\"),\n      ui.output_table(\"table_output\"),\n      # ui.output_text(\"geocoder\"),\n      ui.page_fluid(output_widget(\"map\")),\n    ),  \n    ui.nav_panel(\"By Distance\", \n      ui.br(),\n      ui.input_numeric(\"length\", \"How long is your drive in km (one way)?\", 0),\n      ui.input_slider(\"n_pax_d\", \"Number of People in the Car:\", min=2, max=6, value=2, ticks=True),\n      ui.input_task_button(\"search_d\", \"Search\"),\n      ui.output_table(\"table_output_d\")\n    )\n  )\n)\n\ndef server(input, output, session):\n    @reactive.event(input.search)\n    def calc_geocode():\n      address = input.source_address()\n      url = f\"https://nominatim.openstreetmap.org/search?addressdetails=1&q={address}&format=json\"\n      r = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})\n      response = r.json()[0]\n      return response\n\n    @reactive.calc\n    def parse_geocode():\n      response = calc_geocode()\n      lat = float(response['lat'])\n      lon = float(response['lon'])\n      name = response['display_name']\n      gc_dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n\n      # Get suburb if exists, \"\" otherwise\n      address = response['address']\n      if address.get('suburb') is not None:\n        suburb = address['suburb']\n      else:\n        suburb = \"\"  \n      output = {\n        'lat': lat,\n        'lon': lon,\n        'gc_dist': gc_dist,\n        'name': name,\n        'suburb': suburb\n      }\n      return output\n\n    def get_road_dist(search_term):\n      # Case when we can't code to a suburb\n      if search_term == \"\":\n        return -1\n  \n      match = dist_heuristics.loc[dist_heuristics['locality'].str.contains(search_term, case=False, na=False), 'distance']\n\n      # Cases when can't find match or match to unknown distance metrics\n      if match.empty or match.iloc[0] == \"unknown\":\n        result = -1\n      else:\n        result = float(match.iloc[0])/1e3\n      return result\n\n    # @output\n    # @render.text()\n    # def debugger():\n    #   return parse_geocode()\n\n    @output\n    @render.text()\n    def confirmation():\n      return f\"The address you entered is:\\n{parse_geocode()['name']}\"\n      # return 'hello'\n\n    @output\n    @render.table\n    def table_output():\n      geocode = parse_geocode()\n      suburb = geocode['suburb']\n      # pprint_dist = lambda dist: str(round(dist, 2)) + \" km\"\n\n      gc_dist = geocode['gc_dist']\n      gc_dist_str = dist_to_str(gc_dist)\n      road_dist = get_road_dist(suburb)\n      if road_dist &lt; 0:\n        road_dist_str = \"Unable to calculate road distance, using direct distance instead.\"\n        dist = gc_dist\n      else:\n        road_dist_str = dist_to_str(road_dist)\n        dist = road_dist\n\n      # assuming 10 L/100km & $2.5/L fuel for return\n      cost_ppax = dist * 0.1*2.5 / input.n_pax() * 2\n      cost_ppax_str = cost_to_str(cost_ppax) #\"$\" + str(round(cost_ppax,2))\n\n      output = []\n      output.append({\"Item\": \"Suburb\", \"Value\": suburb})\n      output.append({\"Item\": \"Approximate Road Distance (one way)\", \"Value\": road_dist_str})\n      output.append({\"Item\": \"Direct Distance (one way)\", \"Value\": gc_dist_str})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_ppax_str})\n      \n      return pd.DataFrame(output)\n \n    @render_widget  \n    def map():\n        response = calc_geocode()\n        \n        lat = float(response['lat'])\n        lon = float(response['lon'])\n        bounds = ((DEST_LAT, DEST_LON), (lat, lon))\n\n        m = Map(center=(DEST_LAT, DEST_LON), zoom=10)\n        # geo_layer = GeoJSON(\n        #     data=data\n        # )\n        m.add(Marker(location=(DEST_LAT, DEST_LON), title=\"Destination\"))\n        m.add(Marker(location=(lat, lon)))\n        print(type(lat))\n        m.fit_bounds(bounds)\n        # m.add(geo_layer)\n        return m\n\n    @output\n    @render.table\n    @reactive.event(input.search_d)\n    def table_output_d():\n      n_pax = input.n_pax()\n      length = input.length()\n      cost_ppax = length * 0.1*2.5/n_pax\n\n      output = []\n      output.append({\"Item\": \"Distance (one way)\", \"Value\": dist_to_str(length)})\n      output.append({\"Item\": \"Fuel Cost for Return/pax\", \"Value\": cost_to_str(cost_ppax)})\n      return pd.DataFrame(output)\n\n    # @render.table\n    # def table_output():\n    #   output = []\n    #   output.append({\"Item\": \"aa\", \"Value\": 12})\n    \n    #   return pd.DataFrame(output)\n\n\n    # @render.text\n    # def echo():\n    #   response = calc_geocode()\n    #   lat = float(response['lat'])\n    #   lon = float(response['lon'])\n    #   name = response['display_name']\n    #   dist = great_circle_distance(lat, lon, DEST_LAT, DEST_LON)\n    #   return f'{lat}, {lon}, {name}, {dist}'\n\napp = App(app_ui, server)"
  },
  {
    "objectID": "bonus.html#pack-list",
    "href": "bonus.html#pack-list",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "Pack List",
    "text": "Pack List\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`"
  },
  {
    "objectID": "bonus.html#schedule",
    "href": "bonus.html#schedule",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "Schedule",
    "text": "Schedule\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n\n\nTime\nActivity\n\n\n\n\n09:00\nWake"
  },
  {
    "objectID": "bonus.html#the-menu",
    "href": "bonus.html#the-menu",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "The Menu",
    "text": "The Menu\nQuarto„ÅßÊó•Êú¨Ë™û„ÇÇË°®„Åõ„Çã \\[\n\\int_0^\\infty x dx \\to \\infty\n\\]"
  },
  {
    "objectID": "bonus.html#methodology",
    "href": "bonus.html#methodology",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "The Direct Distance is equivalent to the Great Circle Distance and measures out the length (in km) ‚Äúas the crow flies‚Äù which is the shortest distance between two points on a sphere. This is done by taking the latitude & longitude of two points and computing the Haversine formula.\nThe Road Distance takes into account the roads required to arrive at the destination. By far this is the more accurate measure.\n\n\n\n\n\nWhere possible, it will use the road"
  },
  {
    "objectID": "bonus.html#methodology-all-the-nerdy-details",
    "href": "bonus.html#methodology-all-the-nerdy-details",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "The Direct Distance is equivalent to the Great Circle Distance and measures out the length (in km) ‚Äúas the crow flies‚Äù which is the shortest distance between two points on a sphere. This is done by taking the latitude & longitude of two points and computing the Haversine formula.\nThe Road Distance takes into account the roads required to arrive at the destination. In this specific case, we apply an approximation since we can‚Äôt calculate the exact road distance. By far this is the more accurate measure.\n\nThis tool will use the road distance by default.\n\n\n\nThere is no easy & free way to calculate the road distance using this tool.\n\nThe ‚Äòbest‚Äô way to get road distance is using the Google maps API, which is not a free option.\nThere are open source versions such as Open Route Service, but these have daily free limits and require an API key. Currently this website is hosted on github using shinylive. This enables the web client to run a lot of compute (rather than having a dedicated server), but the downside is there is no real way to hide secret API keys.\n\n\n\n\nAlthough it cannot dynamically calculate road distances according to user input, it can calculate the road distance of a set of preset locations. This is what I did:\n\nSome bloke called Matthew Proctor has a great database of Victorian postcodes & suburbs, which I downloaded.\nUsing Nominatim, each suburb/postcode was geocoded to a latitute & longitude, giving me about 800 results.\nFor each latitute & longitude, I used Open Route Service to calculate the road distance to the target destination (only about 20 of them failed).\n\nSo now I have a list of suburbs and their ‚Äògeneral‚Äô distance to the target destination. There are three options I have here.and\n\n\nThis is the easiest but the least accurate method. Basically, when the user puts in an address, I geocode that address to a suburb.\n\nIf a suburb is found, then that‚Äôs the source from which I calculate the road distance.\nIf a suburb is not found, then it gives up trying to calculate road distance.\n\nEssentially it calcualtes ‚Äòone‚Äô road distance per suburb and tries to match on that.\n\n\n\nRather than assume the ‚Äòclosest‚Äô viable point is the suburb the source address is in, this may not always be true. Each time you run a query, it will search the entire database of suburbs to find the closest one. But the basic implementation of this is \\(\\mathcal{O}(n)\\) where \\(n\\) is the number of rows in the known suburb list. It‚Äôs kinda costly implenentation especially web-client side.\n\n\n\nClosest suburb doesn‚Äôt mean it‚Äôs the right direction. One could conceivably head the wrong way first. We need to find suburb: \\[\nk_{min} = argmin(d_{s,k} + d_{k,d})\n\\] Then once we find this suburb we apply: \\[\nd = d_{s,k_{min}}^{gc} + d_{k_{min},d}^{road}\n\\]\n\n\n\n\nWhere possible, it will use the road"
  },
  {
    "objectID": "bonus.html#all-the-nerdy-details",
    "href": "bonus.html#all-the-nerdy-details",
    "title": "‚≠ê Bonus ‚≠ê",
    "section": "",
    "text": "Source location = where you are coming from.\nDestination location = where you are going (in this case it‚Äôs set to Cowes Phillip Island)\n\n\n\n\nThe Direct Distance is equivalent to the Great Circle Distance and measures out the length (in km) ‚Äúas the crow flies‚Äù which is the shortest distance between two points on a sphere. This is done by taking the latitude & longitude of two the locations and computing the Haversine formula.\nThe Road Distance takes into account the roads required to arrive at the destination. This requires sophisticated graph solving algorithms which is often not worth building yourself. By far this is the more accurate measure.\n\nWe will use an approximation of Road Distance by default - if this cannot be found, then it fallsback to using Direct Distance.\n\n\n\nCalculating the Road Distance requires sophisticate graph solving algorithms and can be grouped in the class of shortest path problem (eg. Dijkstra‚Äôs algorithm). It is not a great idea to write a custom solver because:\n\nThe tool runs almost entirely on the client-side web browser. It is a terrible idea to try to implement graph solving algorithms on web browsers.\nThe effort of writing one up from scratch is useful only insofar as it provides pedogogical value. It just doesn‚Äôt make sense since these tools are already readily available as APIs.\n\nSo if there are APIs available, why can‚Äôt we use it for this tool? Let‚Äôs consider the two main options:\n\nGoogle Maps - this arguable the ‚Äòbest‚Äô way to get routing information, but the API is not free.\nOpen Route Service - this is technically free, but has API limits, which require the user to provide an API key.\n\nSince this tool is built using shinylive, all of its ‚Äòservers‚Äô are client-facing. The client browser is where the backend is run afterall. However, the downside to this is there is no real way to hide API secret keys, since to use the key we will have to eventually expose the secret to the end-user.\n\n\n\nWe are unable to dynamically calculate the route according to user-input of source location because of API restrictions. However, since the destination location is already fixed, we can calculate a set of distances from a list of suburbs. This will be useful in providing the approximation.\n\n\n\nObtain a list of Victorian suburbs and postcodes - Matthew Proctor has a great database of this!\nClean up suburbs dataset - we only really need to keep the metropolitan area subset for our usecase, so we filter by SA4. This ends up being about 800 entries.\nGeocode each suburb to a latitutde & longitude using Nominatim.\nFor each suburb, use Open Route Service to calculate the road distance (only about 20 of them failed).\n\nNow we have a list of suburbs with reference road distances - how do we use this information?\n\n\n\nThis is by far the simplest, but least accurate way. From the user-input, we find the suburb of the source location:\n\nIf a suburb is found, then we impute the road distance from the reference set.\nIf a suburb is not found, we give up on calculating the road distance.\n\n\n\n\nThe obvious flaw with the above method is your location may be in a suburb, but you might actually be closer to another suburb‚Äôs centroid! We can adjust the methodology:\n\nCalculate the direct distance between the source location & each suburb.\nChoose the suburb that is the closest to the source location and use that to impute the road distance value.\n\nThe tricky thing with this method is the computation is \\(\\mathcal{O}(n)\\) according to the complexity of the reference set. This may be fine since we have a short list, but client-side only processing may be a limiting factor.\n\n\n\nThe above method can be flawed as well, since the reference suburb you choose may actually be further away from your destination that the source location. The adjusted methodology is:\n\nCalculate the direct distance between the source location & each suburb: \\(d_{gc}\\)\nFind the suburb that minimises the sum of \\(d_{gc}\\) and the road distance in the reference dataset \\(d_{road}\\)\nThe approximate road distance is precisely this sum.\n\nThe benefit of this method is that it will favour an imputed road distance of a suburb that may be further from the source, but actually on the way to the destination. This method is computationally equivalent to Method 2.\n\n\n\n\n\nUsing approximate road distance where possible.\nThe average fuel efficiency is assumed to be 10L per 100km.\nThe cost of fuel is assumed to be $2.5/L."
  }
]